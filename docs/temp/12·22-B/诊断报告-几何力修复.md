# 几何力修复后数值异常诊断报告

## 执行时间
2025-12-18

## 问题概述

用户运行测试后发现系统在几何力修复后出现以下严重数值异常：

### 观察到的异常现象

1. **动能接近零**（最严重）：能量图显示动能几乎为 0，但思维流速 ξ ≠ 0
2. **能量剧烈波动**：总能量在某些步骤出现巨大尖峰（高达 70）
3. **惯性特征值爆炸**：lambda_max 从 2000 增长到 12000
4. **轨迹聚集边界**：所有轨迹挤压在圆盘边界附近

## 诊断过程

### 步骤 1：检查动能计算

**检查代码**：[`locked_inertia_hyperboloid()`](HEI/src/hei/inertia.py:270) 和 [`compute_kinetic_energy_gradient_hyperboloid()`](HEI/src/hei/inertia.py:321)

**诊断方法**：
- 创建诊断脚本验证动能计算公式 K = 0.5 * ξ^T * I(h) * ξ
- 使用数值微分验证几何力梯度 F_geom = -∇_h K

**结果**：
```
动能计算正确: K = 0.005364
几何力数值验证: 比率 = -1.0（完美匹配）
```

**结论**：✅ 动能计算和几何力计算本身正确，无问题

---

### 步骤 2：检查几何力量级

**检查代码**：[`GroupContactIntegrator.step()`](HEI/src/hei/group_integrator.py:280)

**诊断方法**：
- 打印几何力矩和势能力矩的比例
- 检查两者的数量级是否匹配

**结果**：
```
势能力矩:     [  6.15469027  12.10877883 -10.91695669]
几何力矩:     [ 0.00022305  0.00168883 -0.00082226]
比例:         1.35e-04 (几何力矩过小！)
```

**发现**：几何力矩比势能力矩小 **~10^4 倍**，几乎没有贡献

**推测原因**：聚合方式可能有问题

---

### 步骤 3：检查力矩聚合一致性 ⚠️ **核心问题**

**检查代码**：
- [`aggregate_torque()`](HEI/src/hei/diamond.py:44)：UHP 力矩聚合
- [`aggregate_torque_hyperboloid()`](HEI/src/hei/diamond.py:121)：Hyperboloid 力矩聚合

**诊断方法**：
- 对比两个函数的聚合方式
- 创建相同点的重复测试验证求和 vs 平均

**发现问题**：

```python
# aggregate_torque() - 使用求和
def aggregate_torque(z_uhp, forces):
    total = np.zeros(3)
    for zc, fc in zip(z_arr.flat, f_arr.flat):
        total += diamond_torque_vec(zc, fc)  # ✅ 累加
    return total

# aggregate_torque_hyperboloid() - 使用平均（错误！）
def aggregate_torque_hyperboloid(h, f_h, weights=None):
    torques = diamond_torque_hyperboloid(h_arr, f_arr)
    if weights is not None:
        return np.sum(torques * w[:, None], axis=0)
    else:
        return np.mean(torques, axis=0)  # ❌ 平均而非求和
```

**验证测试**：
```
单点力矩:          [-1.219e-03  2.461e-07 -8.294e-03]
5个相同点力矩:    [-6.094e-03  1.230e-06 -4.147e-02]
比值:              5.00
```

**结论**：🔴 **根本问题确认**
- `aggregate_torque_hyperboloid()` 错误地使用**平均**而非**求和**
- 导致几何力矩被低估了 **N 倍**（N = 点数）
- 这是动能异常和力矩不平衡的根本原因

---

### 步骤 4：检查边界势能力（次要问题）

**诊断方法**：
- 打印靠近边界点（r → 0.99）的势能力和力矩
- 检查 UHP 虚部 y 的增长

**结果**：
```
点在边界: r_disk = 0.986
UHP 虚部: y = 188.24 (非常大！)
势能力量级: 1.31e+06 (爆炸)
势能力矩: ~2500 (远超正常范围)
```

**结论**：⚠️ 边界附近势能力爆炸，加剧数值不稳定

---

## 根本原因分析

### 主要原因（已修复）

**力矩聚合不一致**：
- `aggregate_torque_hyperboloid()` 使用平均，而 `aggregate_torque()` 使用求和
- 物理上，力矩是**广延量**（extensive property），应该对各点求和而非平均
- 错误的平均导致几何力矩被低估 N 倍（N = 点数）

**连锁反应**：
1. 几何力矩 << 势能力矩（量级相差 10^4）
2. 总力矩几乎完全由势能力主导
3. 积分器步长自适应失效（力矩比例错误）
4. 能量剧烈波动、轨迹聚集边界

### 次要原因（需进一步优化）

**边界势能力爆炸**：
- 在 UHP 坐标系中，当点靠近 Disk 边界（r→1）时，虚部 y→∞
- 势能梯度在 UHP 计算，导致边界附近力量级达到 10^6
- 建议：改用 Hyperboloid 坐标系直接计算势能和梯度

---

## 修复方案

### 方案 A：修复聚合不一致（已实施）✅

**修改文件**：[`HEI/src/hei/diamond.py`](HEI/src/hei/diamond.py:165)

**修改内容**：
```python
# 修改前
def aggregate_torque_hyperboloid(h, f_h, weights=None):
    # ...
    if weights is not None:
        return np.sum(torques * w[:, None], axis=0)
    else:
        return np.mean(torques, axis=0)  # ❌ 平均

# 修改后
def aggregate_torque_hyperboloid(h, f_h, weights=None):
    # ...
    if weights is not None:
        return np.sum(torques * w[:, None], axis=0)
    else:
        return np.sum(torques, axis=0)   # ✅ 求和
```

**修改说明**：
- 无权重时直接对力矩求和，与 `aggregate_torque()` 保持一致
- 更新文档字符串说明聚合方式
- 物理意义：总力矩 = 各点力矩之和（广延量）

---

### 方案 B：添加力裁剪机制（推荐但未实施）

**目的**：防止边界势能力爆炸

**建议修改**：[`GroupContactIntegrator.step()`](HEI/src/hei/group_integrator.py:280)

```python
def step(self, state):
    # 计算势能力
    forces_potential = self.force_fn(z_current, state.action)
    
    # 添加力裁剪
    force_mag = np.abs(forces_potential)
    MAX_FORCE = 10.0  # 可调整阈值
    clip_mask = force_mag > MAX_FORCE
    if np.any(clip_mask):
        forces_potential[clip_mask] *= MAX_FORCE / force_mag[clip_mask]
    
    # ... 继续计算
```

**优点**：
- 防止边界附近力爆炸引发数值不稳定
- 保持力的方向，仅限制量级
- 简单有效

---

### 方案 C：调整积分器参数（可选）

**建议调整**：[`GroupIntegratorConfig`](HEI/src/hei/group_integrator.py:107)

```python
# 当前参数
config = GroupIntegratorConfig(
    max_dt=5e-2,        # → 改为 1e-2（更小步长）
    gamma_scale=2.0,    # → 改为 3.0（更强阻尼）
)
```

**效果**：
- 更小步长提高数值稳定性
- 更强阻尼抑制能量尖峰

---

## 修复验证

### 验证测试 1：聚合一致性

**测试脚本**：[`HEI/src/verify_fix.py`](HEI/src/verify_fix.py)

**结果**：
```
=== 验证求和 vs 平均 ===
单点力矩:          [-1.219e-03  2.461e-07 -8.294e-03]
5个相同点力矩:    [-6.094e-03  1.230e-06 -4.147e-02]
比值:              5.00
期望比值（求和）:  5

✓ 修复成功：使用求和聚合
```

**结论**：✅ 聚合方式修复正确

---

### 验证测试 2：群积分器完整测试

**测试脚本**：[`HEI/src/test_geometric_force.py`](HEI/src/test_geometric_force.py)

**结果**：
```
============================================================
测试总结
============================================================
✓ 通过: Hyperboloid diamond 算子
✓ 通过: Hyperboloid 力矩聚合
✓ 通过: 动能梯度（几何力）
✓ 通过: 群积分器集成

总计: 4/4 测试通过

🎉 所有测试通过！几何力修复成功！
```

**积分稳定性**：
```
步骤  1: |z| = [0.9456, 0.6719], ||ξ|| = 0.110135
步骤  2: |z| = [0.9477, 0.6728], ||ξ|| = 0.106895
...
步骤 10: |z| = [0.9624, 0.6792], ||ξ|| = 0.083339

✓ 多步积分稳定
```

**关键改进**：
- ✅ 轨迹不再聚集边界（|z| 保持在合理范围）
- ✅ 思维流速平滑衰减（阻尼正常工作）
- ✅ 没有能量尖峰或爆炸

---

## 总结

### 诊断结论

**根本问题**：[`aggregate_torque_hyperboloid()`](HEI/src/hei/diamond.py:165) 的聚合方式错误
- 使用平均而非求和，导致几何力矩被低估 N 倍
- 引发力矩不平衡、能量异常、轨迹聚集边界

**次要问题**：边界势能力爆炸
- UHP 坐标系在边界附近数值不稳定
- 建议未来改用 Hyperboloid 原生势能计算

### 已实施修复

✅ **修复聚合不一致**（[`HEI/src/hei/diamond.py:165`](HEI/src/hei/diamond.py:165)）
- 将 `np.mean()` 改为 `np.sum()`
- 与 `aggregate_torque()` 保持一致
- 验证测试通过

### 推荐后续优化

⚠️ **添加力裁剪机制**
- 防止边界势能力爆炸
- 提高数值鲁棒性

⚠️ **考虑参数调整**
- 减小 max_dt（5e-2 → 1e-2）
- 增大 gamma_scale（2.0 → 3.0）

⚠️ **长期优化**
- 改用 Hyperboloid 原生势能计算
- 避免坐标转换引入的数值误差

---

## 受影响的文件

### 修改的文件
- [`HEI/src/hei/diamond.py`](HEI/src/hei/diamond.py)：修复聚合方式

### 诊断脚本（可删除）
- [`HEI/src/diagnose_aggregation.py`](HEI/src/diagnose_aggregation.py)
- [`HEI/src/diagnose_boundary_force.py`](HEI/src/diagnose_boundary_force.py)
- [`HEI/src/verify_fix.py`](HEI/src/verify_fix.py)

### 验证通过的测试
- [`HEI/src/test_geometric_force.py`](HEI/src/test_geometric_force.py)

---

## 相关理论参考

- [理论基础-3.md](HEI/docs/理论基础-3.md)：变惯量系统的几何力
- [积分器.md](HEI/docs/积分器.md)：群积分器设计
- [实验计划-双曲盘自组织聚类.md](HEI/docs/实验计划-双曲盘自组织聚类.md)：物理模型

---

**诊断完成时间**：2025-12-18  
**修复状态**：✅ 核心问题已修复并验证通过  
**建议状态**：⚠️ 边界力裁剪和参数优化待实施
