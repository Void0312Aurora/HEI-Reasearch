## 3) 关键风险与潜在不匹配（优先级从高到低）

### 风险 1（最高）：`exp_sl2()` 对 dt 的缩放在主分支疑似错误，会直接导致爆炸/漂移

`exp_sl2()` 的注释写的是 `exp(A)=cosh(s)I + sinh(s)/s * A, s=dt*sqrt(u^2+vw)` 。  
但实现里在 `s>=1e-8` 时返回 `ch*I + sh_over_s * A` ；**此处应当是 `ch*I + sh_over_s * (dt*A)`（或等价写法）**，否则小步长下会出现“不是 (I+dtA) 而是接近 (I+A)”的灾难性放大。

这会同时污染：

- 位置更新：积分器每步 `g_step = exp_sl2(xi_new, dt)` 再做 Möbius 作用 ；
    
- 共伴随输运：`_coadjoint_transport()` 用 `g=exp_sl2(xi,dt)` 做矩阵共轭 ；
    
- dt 回溯判据也依赖 `exp_sl2(xi, dt)` 的位移估计 。
    

**结论**：只要 dt≠1 且进入主分支，这个错误就足以解释“数值爆炸/异常收敛方向”。建议把它作为第一修复项，并为 `exp_sl2` 加单元测试（见第 4 节建议）。

---

### 风险 2：积分器方程的标度不一致（docstring 写 h²J，代码/残差用 h·torque）

积分器 docstring 写的动量更新是：  
`I(a_k) xi_k = alpha_{k-1} Ad^*(...)+ h^2 J(a_k)` 。

但仿真里对动量残差的检查使用的是  
`... - dt_used * torque_new` ，并且主循环里也把 `torque` 当作与 dt 一次相乘的“力矩”使用（更符合连续时间外力离散）。

这意味着当前存在两种可能：

1. **docstring 过时/写错**（实际上应是 (h J)）；
    
2. **`torque` 的定义相当于 (h J)**（但代码里 torque 来自 `aggregate_torque()`，看起来是纯几何/力的函数，与 dt 无关 ）。
    

无论哪种，都建议统一：要么修正文档方程，要么把实现改成与理论一致，并用残差项作为回归测试基准。

---

### 风险 3：边界“安全夹断”会破坏几何真实性，可能制造系统性偏置（例如“右侧聚集”）

几何层为避免 Cayley 在 disk 的 (z\to 1) 奇异，对半径做了较强 clamp（`eps=1e-4`），并对 UHP 也做了 `max_re/max_im` 截断 。积分器每步还把点投影回“安全区域” 。

这类硬截断会带来两类问题：

- **破坏等距群作用的可逆性/光滑性**：你理论里依赖接触变分结构的光滑性，但 clamp 是非光滑的；
    
- **方向性偏置**：Cayley 奇异点本身位于 disk 的 (z=1) 方向，你越是“推开奇异”，越可能在数值上引入对该方向的非对称响应（这与测试文件里专门诊断“右侧边界不稳定/右侧收敛”是一致的动机 ）。
    

---

### 风险 4：惯性张量的谱夹断虽能救稳定性，但会显著改变动力学（尤其是靠边界）

`locked_inertia_uhp()` 里惯性项按 (1/y^2) 放大，并允许非常大（`MAX_INERTIA_SCALE=1e14`），随后又对特征值做 `EIG_FLOOR=1e-3` / `EIG_CAP=1e14` 的夹断 。

这会导致：

- 在边界附近，系统的“真实”惯性结构可能被硬改，**从而破坏你期望的几何能量/动量守恒性质**；
    
- 由于 `invert_inertia()` 直接求解线性方程 ，谱夹断会把某些方向的加速度响应从“物理上决定”变成“数值上决定”，很容易出现非物理的集中/喷射现象。
    

测试里也专门针对 “z→1 时惯性是否奇异或过小导致 a=F/m 发散”做了诊断构想 ，说明你们已经意识到这是核心故障点之一。

---

### 风险 5：(\diamond) 的复数力/共轭约定需再核对，否则会出现“力方向反了”的系统性错误

`diamond_torque_matrix()` 用的是 `Re(z * conj(f))`、`Re(conj(f)*z^2)`、以及 `Re(f)` 。这隐含了“把复数梯度当作某种共轭约定下的 1-form”的选择。

但你们势能接口明确说返回的是 covector 分量 (\partial V/\partial x + i \partial V/\partial y)（欧式偏导），在不同的复数约定下，diamond 里是否该用 `f` 还是 `conj(f)`、以及矩阵系数的正负号，都可能导致**全局方向性错误**。`test_1_force_direction()` 也正是为了验证“力是否把点推向目标还是推向相反方向” ，这类测试建议尽快跑通并固化为回归测试。

---

## 4) 我建议你们立即做的“最小修复集”（能最快提升可行性）

1. **修复 `exp_sl2()` 的 dt 缩放，并加 3 个单测**
    
    - 小 dt：`exp_sl2(xi, dt)` 应满足 (g \approx I + dt A)（用 Frobenius 范数检验）。
        
    - 群性质：`exp_sl2(xi, dt1)` 与 `exp_sl2(xi, dt2)` 乘积应接近 `exp_sl2(xi, dt1+dt2)`（至少在小步长/小范数下）。
        
    - `det(g)` 应接近 1（SL(2)）。目前实现里还对 `s` 做 clamp 以避免 cosh/sinh 溢出 ，这会进一步破坏精确性，建议把“防溢出”策略改为“缩放 + 对数形式”或在仿真层限制 `|xi|*dt`（你们已经有 step_clip/xi_clip 的思路 ）。
        
2. **统一动量更新的离散标度（h·torque vs h²·J）**
    
    - 以 `run_simulation()` 的残差定义为准先统一（它现在是 dt·torque）；然后修正 docstring 方程 或调整实现，使理论与代码一致。
        
3. **把“安全夹断”从硬截断逐步替换为“软势/软投影”**
    
    - 例如：用额外势能项在 disk 边界附近提供可微的 barrier，而不是在 `cayley_disk_to_uhp()` 做硬 clamp 。这样更符合你理论里对变分结构与耗散结构的要求，也更利于诊断（因为 clamp 会把问题“吞掉”）。
        
4. **验证 (\diamond) 的符号与共轭约定**
    
    - 直接用你们的 `test_1_force_direction()` 作为基准 ，并再补一个“有限差分一致性”：对单点势 (V(z)) 做数值差分，确认 `dV_dz` 与 diamond 生成的扭矩在理论预期方向一致。
        
