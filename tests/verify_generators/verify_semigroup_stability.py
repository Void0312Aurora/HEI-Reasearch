"""
Verify L1 Dynamics Generators (Semigroup Stability).

This script verifies that the offline evolution operator T(t) generated by the entity
satisfies the properties of a C0-semigroup with bounded growth (dissipative).

Metrics:
1. Growth Bound (omega_0):
   lim_{t->0} ln(||T(t)||) / t <= omega_0
   We estimate this by rolling out for small t and computing linear regression slope of log norm.

2. Monotonicity (Lyapunov-like):
   Checks if a candidate Lyapunov function (e.g., Energy/Hamiltonian) is non-increasing
   during offline evolution (u=0).

Targets:
- omega_0 should be <= 0 (Contractive) or close to 0 (Conservative).
- Energy should be monotonically decreasing (Dissipative).
"""
import torch
import numpy as np
import matplotlib.pyplot as plt
import os
from typing import Dict, List, Tuple

from he_core.entity_v4 import UnifiedGeometricEntity

def estimate_growth_bound(entity, dt: float = 0.01, steps: int = 50, num_samples: int = 10) -> float:
    """
    Estimate the growth bound omega_0 of the dynamics semigroup.
    ||T(t)x|| <= M * exp(omega_0 * t) * ||x||
    
    We approximate omega_0 as the slope of max(ln(||x(t)|| / ||x(0)||)) vs t.
    """
    entity.reset()
    # Override reset to use batch scaling
    # We want to sample around the origin to test local stability, or globally.
    # Let's test local behavior near 0.
    batch_size = num_samples
    dim_q = entity.dim_q
    
    # Initialize random states
    q0 = torch.randn(batch_size, dim_q)
    p0 = torch.randn(batch_size, dim_q) * 0.1 # Small velocity
    s0 = torch.zeros(batch_size, 1)
    
    # We need to manually set the batch in the entity state
    # But entity.state is currently (dim_q, 1). 
    # For this test, we need a batched entity or run sequentially.
    # The current v4 entity might not support runtime batch size change easily if hardcoded.
    # Let's check entity implementation. 
    # v4 UnifiedGeometricEntity initializes state with batch scale.
    # The ContactState supports batch_size.
    # But UnifiedGeometricEntity __init__ sets self.state = ContactState(dim_q, 1).
    # We can try to manually replace the state with a batched one if the methods support it.
    
    # To be safe and compliant with current API, let's run sequential samples.
    log_ratios = []
    times = []
    
    for k in range(num_samples):
        entity.reset() # q ~ N(0, 0.1)
        x0_flat = entity.state.flat.clone()
        norm0 = x0_flat.norm().item()
        
        current_log_ratios = []
        
        # Rollout
        for step in range(steps):
            t = step * dt
            # Step with u=0 (Offline)
            u_zero = torch.zeros(1, entity.dim_u)
            # Use forward_tensor with u=0
            out = entity.forward_tensor(entity.state.flat, u_zero, dt)
            
            # Update state
            entity.state.flat = out['next_state_flat'].detach()
            
            xt_flat = entity.state.flat
            norm_t = xt_flat.norm().item()
            
            ratio = norm_t / (norm0 + 1e-9)
            current_log_ratios.append(np.log(ratio))
            
            if k == 0:
                times.append(t)
        
        log_ratios.append(current_log_ratios)
    
    # Average log ratio at each step (or max for worst case growth)
    log_ratios = np.array(log_ratios) # (samples, steps)
    
    # Use MAX growth across samples to bound the operator norm ||T(t)||
    # ||T(t)|| = sup_x ||T(t)x||/||x||
    # So we take max over samples.
    max_log_ratios = np.max(log_ratios, axis=0)
    
    # Linear fit to get omega_0
    # ln(||T(t)||) ~ omega_0 * t
    slope, intercept = np.polyfit(times, max_log_ratios, 1)
    
    return slope, times, max_log_ratios

class ZeroModule(torch.nn.Module):
    def forward(self, x):
        return torch.zeros(x.shape[0], 1, device=x.device)

def verify_monotonicity(entity, dt: float = 0.1, steps: int = 100) -> Tuple[bool, List[float]]:
    """
    Verify that the Mechanical Energy (Kinetic) is non-increasing under zero potential.
    We enforce V(q)=0 for this test to isolate dissipative structure:
    dot_p = -alpha * p
    E = 0.5 * p^2
    """
    # 1. Nullify Potential to verify pure dissipation
    # We patch the network to output 0
    if hasattr(entity, 'internal_gen') and hasattr(entity.internal_gen, 'net_V'):
        # Save original
        original_V = entity.internal_gen.net_V
        # Replace with zero module
        entity.internal_gen.net_V = ZeroModule()
    
    entity.reset()
    energies = []
    
    # Ensure initial velocity is non-zero
    entity.state.p = torch.randn_like(entity.state.p) * 1.0
    
    for step in range(steps):
        # Calculate Mechanical Energy: K = 0.5 * p^2
        K = 0.5 * (entity.state.p**2).sum(dim=1).item()
        
        # Step
        u_zero = torch.zeros(1, entity.dim_u)
        out = entity.forward_tensor(entity.state.flat, u_zero, dt)
        entity.state.flat = out['next_state_flat'].detach()
        
        energies.append(K)
        
    energies = np.array(energies)
    
    # Restore Potential (if needed, though entity is local)
    # if hasattr(entity, 'internal_gen'):
    #     entity.internal_gen.net_V = original_V
    
    # Check monotonicity: E[t+1] <= E[t] + epsilon
    epsilon = 1e-6
    diffs = energies[1:] - energies[:-1]
    
    # Violations
    violations = np.sum(diffs > epsilon)
    is_monotonic = (violations == 0)
    
    # Trend
    avg_slope = (energies[-1] - energies[0]) / (steps * dt)
    
    return is_monotonic, energies, avg_slope

def run_diagnostics():
    import sys
    print("=== Phase 16.1: L1 Dynamics Diagnostics (Fix) ===", file=sys.stderr)
    
    # Config: High Damping
    config = {
        'dim_q': 2,
        'learnable_coupling': False, 
        'num_charts': 1,
        'damping': 5.0, # Strong dissipation
        'use_port_interface': False # Disable port for pure dynamics check
    }
    
    print(f"Configuration: damping={config['damping']}", file=sys.stderr)
    entity = UnifiedGeometricEntity(config)
    
    # 1. Growth Bound
    print("\n--- 1. Semigroup Growth Bound (omega_0) ---", file=sys.stderr)
    # Use Null Potential for growth check too to avoid drift
    original_V = entity.internal_gen.net_V
    entity.internal_gen.net_V = ZeroModule()
    
    omega_0, times, log_norms = estimate_growth_bound(entity, dt=0.01, steps=100, num_samples=20)
    print(f"  Estimated omega_0: {omega_0:.4f}", file=sys.stderr)
    
    is_stable = omega_0 < 0.1 # Should be near 0 or negative
    print(f"  Result: {'STABLE' if is_stable else 'UNSTABLE'}", file=sys.stderr)
    
    # 2. Monotonicity
    print("\n--- 2. Energy Monotonicity (Mechanical) ---", file=sys.stderr)
    # verify_monotonicity applies the Null Potential patch internally
    is_mono, energies, trend = verify_monotonicity(entity, dt=0.05, steps=200)
    print(f"  Monotonic: {is_mono}", file=sys.stderr)
    print(f"  Energy Trend (slope): {trend:.6f}", file=sys.stderr)
    print(f"  Initial Energy: {energies[0]:.4f}", file=sys.stderr)
    print(f"  Final Energy:   {energies[-1]:.4f}", file=sys.stderr)
    
    # Restore V
    entity.internal_gen.net_V = original_V

    # Output for parsing (stdout)
    print(f"omega0={omega_0:.4f}")
    print(f"monotonic={is_mono}")
    print(f"trend={trend:.6f}")
    
    # Save Plot
    plt.figure(figsize=(10, 4))
    
    plt.subplot(1, 2, 1)
    plt.plot(times, log_norms)
    plt.plot(times, np.array(times) * omega_0, 'r--', label=f'Fit $\omega_0$={omega_0:.2f}')
    plt.title('Semigroup Growth (V=0)')
    plt.xlabel('Time (t)')
    plt.ylabel('ln(||x(t)||/||x(0)||)')
    plt.legend()
    plt.grid(True)
    
    plt.subplot(1, 2, 2)
    plt.plot(energies)
    plt.title('Kinetic Energy Decay (V=0)')
    plt.xlabel('Step')
    plt.ylabel('K = 0.5 p^2')
    plt.grid(True)
    
    os.makedirs('tests/verify_generators/results', exist_ok=True)
    plt.savefig('tests/verify_generators/results/L1_stability.png')
    print("\n  Plot saved to tests/verify_generators/results/L1_stability.png", file=sys.stderr)

if __name__ == "__main__":
    run_diagnostics()
