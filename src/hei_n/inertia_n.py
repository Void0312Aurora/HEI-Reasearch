"""
Variable Inertia and Diamond Operator for HEI-N.
===============================================

Handles the mapping between Velocity (xi) and Momentum (M) in the Lie Algebra,
and calculates the "Diamond" structure feedback torque.

Theory:
- M = I(a) * xi
- xi = I(a)^{-1} * M
- Torque = dV/da diamond a
- F_geom = -grad_a (0.5 * <xi, I(a) xi>)

"""
import numpy as np
import dataclasses
from typing import Protocol, Tuple

from .lie_n import minkowski_metric
from .geometry_n import minkowski_inner

class InertiaModelN(Protocol):
    """Protocol for position-dependent inertia."""
    
    def mass(self, x: np.ndarray) -> np.ndarray:
        """Return scalar mass for each particle. Shape (N,)"""
        ...
        
    def inverse_inertia(self, M: np.ndarray, x: np.ndarray) -> np.ndarray:
        """Map Momentum M -> Velocity xi. xi = M / mass(x)."""
        ...
        
    def kinetic_energy(self, M: np.ndarray, x: np.ndarray) -> float:
        """Compute T = 0.5 * <xi, M>."""
        ...
        
    def geometric_force(self, M: np.ndarray, x: np.ndarray) -> np.ndarray:
        """Compute F_geom = -grad T."""
        ...

def compute_diamond_torque(G: np.ndarray, F_world: np.ndarray) -> np.ndarray:
    """
    The Diamond Operator (Structure Feedback).
    Computes body torque generated by a world force F at configuration G.
    
    Torque = x_body ^ F_body
    (For x0 = e0).
    """
    dim = G.shape[-1]
    J = minkowski_metric(dim)
    
    # 1. Pull back Force to Body Frame
    # G_inv = J @ G.T @ J
    G_inv = J @ np.swapaxes(G, -1, -2) @ J
    F_body = (G_inv @ F_world[..., np.newaxis]).squeeze(-1)
    
    # 2. Construct Torque
    T = np.zeros_like(G)
    f_rest = F_body[..., 1:] 
    
    T[..., 0, 1:] = f_rest
    T[..., 1:, 0] = f_rest
    
    return T

@dataclasses.dataclass
class IdentityInertia:
    """Constant Kinetic Energy I=Id."""
    
    def mass(self, x: np.ndarray) -> np.ndarray:
        return np.ones(x.shape[0])
        
    def inverse_inertia(self, M: np.ndarray, x: np.ndarray) -> np.ndarray:
        return M # xi = M
        
    def kinetic_energy(self, M: np.ndarray, x: np.ndarray) -> float:
        # T = 0.5 * sum(M^2) roughly (on boost/rot components)
        v = M[:, 0, 1:]
        w = M[:, 1:, 1:]
        T = np.sum(v**2) + 0.5 * np.sum(w**2)
        return float(T)
        
    def geometric_force(self, M: np.ndarray, x: np.ndarray) -> np.ndarray:
        # Constant mass => grad T = 0
        return np.zeros_like(x)

@dataclasses.dataclass
class RadialInertia:
    """
    Mass depends on distance from origin (Hyperbolic Radius).
    m(r) = base_mass * (1 + alpha * r^2)
    This creates "Cognitive Friction" or "Heaviness" for deep/far nodes.
    """
    alpha: float = 1.0
    
    def _get_mass(self, x: np.ndarray) -> np.ndarray:
        # x is in R^{n+1}. Origin is (1, 0, ...).
        # cosh(r) = x0 (if x is on H^n).
        # Let's use x0 as proxy for depth?
        # x0 = x[..., 0]
        # m = 1 + alpha * (x0 - 1)
        x0 = x[..., 0]
        m = 1.0 + self.alpha * np.maximum(0, x0 - 1.0)
        return m
        
    def mass(self, x: np.ndarray) -> np.ndarray:
        return self._get_mass(x)
        
    def inverse_inertia(self, M: np.ndarray, x: np.ndarray) -> np.ndarray:
        m = self._get_mass(x)
        return M / m[:, np.newaxis, np.newaxis]
        
    def kinetic_energy(self, M: np.ndarray, x: np.ndarray) -> float:
        # T = 0.5 * xi^T I xi = 0.5 * (M/m)^T (m) (M/m) = 0.5 * M^2 / m.
        v = M[:, 0, 1:]
        w = M[:, 1:, 1:]
        raw_T_per_particle = np.sum(v**2, axis=1) + 0.5 * np.sum(w**2, axis=(1,2))
        
        m = self._get_mass(x)
        T_total = np.sum(raw_T_per_particle / m)
        return float(T_total)
        
    def geometric_force(self, M: np.ndarray, x: np.ndarray) -> np.ndarray:
        # F_geom = - grad_x T
        # T = 0.5 * M^2 / m(x)
        # grad T = -0.5 * M^2 / m^2 * grad m
        
        m = self._get_mass(x)
        v = M[:, 0, 1:]
        w = M[:, 1:, 1:]
        M_sq = np.sum(v**2, axis=1) + 0.5 * np.sum(w**2, axis=(1,2)) # (N,)
        
        # grad m wrt x
        # m = 1 + alpha(x0 - 1)
        # grad m = [alpha, 0, ...]
        
        # F_geom_x = - (- M^2 / 2m^2 * alpha) = (alpha * M^2) / (2 m^2)
        # in direction e0.
        
        prefactor = (self.alpha * M_sq) / (2 * m**2) # (N,)
        
        F = np.zeros_like(x)
        F[..., 0] = prefactor
        
        # But this force must be projected to tangent space!
        # The integrator handles projection of TOTAL force.
        # But F_geom is derived from constrained T? Or unconstrained?
        # Usually easier to return ambient gradient and let integrator project.
        return F
