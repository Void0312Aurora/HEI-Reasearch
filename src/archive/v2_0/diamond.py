"""
Aurora Diamond Operator.
========================

The "Diamond" operator computes the momentum update (torque) generated by a force.
In the Euler-PoincarÃ© formulation on Lie Groups (Left-Invariant), we typically work with:
1.  World Force F (in ambient space R^{n+1}).
2.  Body Torque mu_dot (in Lie Algebra so(1,n)).

The flow is:
    F_world --(Pullback)--> F_body --(Wedge)--> Torque_body

Reference: hei/diamond.py (Legacy UHP version).
"""

import torch

def compute_diamond_torque(G: torch.Tensor, F_world: torch.Tensor) -> torch.Tensor:
    """
    Compute Body Torque from World Force.
    
    Args:
        G: (N, dim, dim) Frame in SO(1,n).
           Column 0 is position x (e_0 in body).
        F_world: (N, dim) Force vector in Minkowski Ambient Space.
        
    Returns:
        Omega: (N, dim, dim) Torque in so(1,n).
        
    Math:
        1. F_body = G^{-1} F_world
           For G in SO(1,n), G^{-1} = J G^T J.
           Effectively F_body components are projections of F_world onto frame axes.
           
        2. Torque = x_body ^ F_body
           Since x_body = e_0 = (1, 0, ...)^T,
           (e_0 ^ F)_{ij} = (e_0)_i F_j - F_i (e_0)_j.
           
           Non-zero terms involve index 0:
           Omega_{0, i} = 1 * F_i - F_0 * 0 = F_i
           Omega_{i, 0} = F_i * 0 - 1 * F_i = -F_i
           (for i > 0).
           
           Note: F_body is a Minkowski vector.
           Strictly, wedge product uses dual?
           Let's stick to the "Boost Generator" identification.
           Torque should generate rotation that moves e_0 towards F_body.
           
           Result matches hei_n: Boost components are simply F_body spatial parts.
    """
    # 1. Pull back to Body F_body = G^{-1} F_world
    
    # J @ F_world
    # J = diag(-1, 1...)
    # We apply J implicitly: 0-th component sign flip.
    JF = F_world.clone()
    JF[..., 0] *= -1.0
    
    # G^T @ (J F)
    # G (N, i, j). F (N, i).
    # G^T y -> sum_i G_ij y_i ? No.
    # y = G x => y_i = sum_j G_ij x_j.
    # x = G^T y => x_j = sum_i G_ij y_i.
    # So we want einsum 'nij,ni->nj'.
    GTJF = torch.einsum('nij,ni->nj', G, JF)
    
    # J @ (G^T J F)
    F_body = GTJF
    F_body[..., 0] *= -1.0
    
    # 2. Construct Torque
    Omega = torch.zeros_like(G)
    vals = F_body[..., 1:] # (N, dim-1)
    
    # Fill boost components
    # Omega_{0, i} = vals_i
    # Omega_{i, 0} = vals_i
    # This creates a symmetric matrix in standard representation?
    # so(1,n) matrices: [0  v^T]
    #                   [v   0 ]
    # Check metric compatibility: X^T J + J X = 0.
    # Let X = [[0, v], [v, 0]].
    # J = [[-1, 0], [0, 1]].
    # X^T = X.
    # X^T J = [[0, v], [v, 0]] @ [[-1, 0], [0, 1]] = [[0, v], [-v, 0]].
    # J X = [[-1, 0], [0, 1]] @ [[0, v], [v, 0]] = [[0, -v], [v, 0]].
    # Sum = [[0, 0], [0, 0]]. OK.
    
    Omega[:, 0, 1:] = vals
    Omega[:, 1:, 0] = vals
    
    return Omega
